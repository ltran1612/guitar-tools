/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/metronome.js":
/*!**************************!*\
  !*** ./src/metronome.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Metronome: () => (/* binding */ Metronome)\n/* harmony export */ });\nclass Metronome {\r\n    constructor() {\r\n        this.audioContext = null;\r\n        this.isPlaying = false;\r\n        this.tempo = 120;\r\n        this.timeSignature = { beats: 4, division: 4 };\r\n        this.currentBeat = 0;\r\n        this.intervalId = null;\r\n        this.volume = 0.5;\r\n        \r\n        // Audio buffers for different click sounds\r\n        this.clickBuffer = null;\r\n        this.accentBuffer = null;\r\n        \r\n        this.initializeAudio();\r\n    }\r\n\r\n    async initializeAudio() {\r\n        try {\r\n            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n            await this.createClickSounds();\r\n        } catch (error) {\r\n            console.error('Error initializing metronome audio:', error);\r\n        }\r\n    }\r\n\r\n    async createClickSounds() {\r\n        // Create regular click sound (higher frequency)\r\n        this.clickBuffer = this.createClickBuffer(800, 0.1);\r\n        \r\n        // Create accent click sound (lower frequency, longer duration)\r\n        this.accentBuffer = this.createClickBuffer(600, 0.15);\r\n    }\r\n\r\n    createClickBuffer(frequency, duration) {\r\n        const sampleRate = this.audioContext.sampleRate;\r\n        const buffer = this.audioContext.createBuffer(1, sampleRate * duration, sampleRate);\r\n        const data = buffer.getChannelData(0);\r\n        \r\n        for (let i = 0; i < data.length; i++) {\r\n            const t = i / sampleRate;\r\n            // Create a click sound with exponential decay\r\n            data[i] = Math.sin(2 * Math.PI * frequency * t) * Math.exp(-t * 10) * this.volume;\r\n        }\r\n        \r\n        return buffer;\r\n    }\r\n\r\n    start() {\r\n        if (this.isPlaying) return;\r\n        \r\n        this.isPlaying = true;\r\n        this.currentBeat = 0;\r\n        \r\n        const intervalMs = (60 / this.tempo) * 1000;\r\n        this.intervalId = setInterval(() => {\r\n            this.playClick();\r\n            this.currentBeat = (this.currentBeat + 1) % this.timeSignature.beats;\r\n        }, intervalMs);\r\n        \r\n        // Play first click immediately\r\n        this.playClick();\r\n    }\r\n\r\n    stop() {\r\n        if (!this.isPlaying) return;\r\n        \r\n        this.isPlaying = false;\r\n        if (this.intervalId) {\r\n            clearInterval(this.intervalId);\r\n            this.intervalId = null;\r\n        }\r\n        this.currentBeat = 0;\r\n    }\r\n\r\n    playClick() {\r\n        if (!this.audioContext || !this.clickBuffer || !this.accentBuffer) return;\r\n        \r\n        // Resume audio context if suspended\r\n        if (this.audioContext.state === 'suspended') {\r\n            this.audioContext.resume();\r\n        }\r\n        \r\n        const buffer = this.currentBeat === 0 ? this.accentBuffer : this.clickBuffer;\r\n        const source = this.audioContext.createBufferSource();\r\n        source.buffer = buffer;\r\n        source.connect(this.audioContext.destination);\r\n        source.start();\r\n    }\r\n\r\n    setTempo(tempo) {\r\n        this.tempo = Math.max(40, Math.min(200, tempo));\r\n        if (this.isPlaying) {\r\n            this.stop();\r\n            this.start();\r\n        }\r\n    }\r\n\r\n    setTimeSignature(beats, division) {\r\n        this.timeSignature = { beats, division };\r\n        this.currentBeat = 0;\r\n    }\r\n\r\n    setVolume(volume) {\r\n        this.volume = Math.max(0, Math.min(1, volume));\r\n        this.createClickSounds(); // Recreate buffers with new volume\r\n    }\r\n\r\n    getCurrentBeat() {\r\n        return this.currentBeat + 1;\r\n    }\r\n\r\n    isAccentBeat() {\r\n        return this.currentBeat === 0;\r\n    }\r\n\r\n    destroy() {\r\n        this.stop();\r\n        if (this.audioContext) {\r\n            this.audioContext.close();\r\n        }\r\n    }\r\n} \n\n//# sourceURL=webpack://guitar-tuner/./src/metronome.js?");

/***/ }),

/***/ "./src/note-detector.js":
/*!******************************!*\
  !*** ./src/note-detector.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoteDetector: () => (/* binding */ NoteDetector)\n/* harmony export */ });\nclass NoteDetector {\r\n    constructor(sampleRate = 44100) {\r\n        // Audio parameters\r\n        this.sampleRate = sampleRate;\r\n        this.blockSize = 32768;\r\n        this.powerThreshold = 0.00001;\r\n        this.minFreq = 60;  // Lower minimum frequency to better catch A2\r\n        this.maxFreq = 4000;\r\n\r\n        // Standard guitar tuning frequencies (E2, A2, D3, G3, B3, E4)\r\n        this.guitarNotes = {\r\n            'E2': 82.41,\r\n            'A2': 110.00,\r\n            'D3': 146.83,\r\n            'G3': 196.00,\r\n            'B3': 246.94,\r\n            'E4': 329.63\r\n        };\r\n\r\n        // Extended note frequencies for higher octaves\r\n        this.extendedNotes = {\r\n            ...this.guitarNotes,\r\n        };\r\n\r\n        // Create Hann window\r\n        this.hannWindow = this.createHannWindow(this.blockSize);\r\n\r\n        // Initialize frequency bands with wider bands for lower frequencies\r\n        this.initializeFrequencyBands();\r\n    }\r\n\r\n    createHannWindow(size) {\r\n        const window = new Float32Array(size);\r\n        for (let i = 0; i < size; i++) {\r\n            window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)));\r\n        }\r\n        return window;\r\n    }\r\n\r\n    initializeFrequencyBands() {\r\n        // Create frequency bands for each note\r\n        this.frequencyBands = {};\r\n        for (const [note, freq] of Object.entries(this.extendedNotes)) {\r\n            // Use wider bands for lower frequencies\r\n            const bandWidth = note.includes('2') ? 0.02 : 0.01;  // 2% for lower notes, 1% for higher\r\n            this.frequencyBands[note] = {\r\n                min: freq * (1 - bandWidth),\r\n                max: freq * (1 + bandWidth),\r\n                center: freq\r\n            };\r\n        }\r\n    }\r\n\r\n    findPeakFrequency(data) {\r\n        // Calculate signal power\r\n        const signalPower = data.reduce((sum, val) => sum + val * val, 0) / data.length;\r\n        \r\n        // Debug signal power\r\n        console.log('Signal Power:', signalPower);\r\n        \r\n        if (signalPower < this.powerThreshold) {\r\n            console.log('Signal too weak');\r\n            return { frequency: null, amplitude: 0 };\r\n        }\r\n\r\n        // Apply Hann window\r\n        const windowedData = data.map((val, i) => val * this.hannWindow[i]);\r\n\r\n        // Calculate FFT\r\n        const fft = this.calculateFFT(windowedData);\r\n        \r\n        // Calculate frequency resolution\r\n        const deltaFreq = this.sampleRate / this.blockSize;\r\n\r\n        // Find the dominant frequency\r\n        const dominantFreq = this.findDominantFrequency(fft, deltaFreq);\r\n        \r\n        if (dominantFreq) {\r\n            // Debug information\r\n            console.log('Frequency Detection:', {\r\n                signalPower,\r\n                dominantFreq: dominantFreq.freq,\r\n                confidence: dominantFreq.confidence,\r\n                closestNote: this.findClosestNote(dominantFreq.freq).note\r\n            });\r\n            \r\n            return { frequency: dominantFreq.freq, amplitude: dominantFreq.confidence };\r\n        }\r\n        \r\n        console.log('No dominant frequency found');\r\n        return { frequency: null, amplitude: 0 };\r\n    }\r\n\r\n    findDominantFrequency(fft, deltaFreq) {\r\n        // Calculate the magnitude spectrum\r\n        const magnitudeSpectrum = new Float32Array(fft.length);\r\n        for (let i = 0; i < fft.length; i++) {\r\n            magnitudeSpectrum[i] = Math.abs(fft[i]);\r\n        }\r\n\r\n        // Find peaks in the magnitude spectrum\r\n        const peaks = this.findPeaks(magnitudeSpectrum, deltaFreq);\r\n        console.log('Found peaks:', peaks);\r\n        \r\n        // Calculate the energy in each frequency band\r\n        const bandEnergies = this.calculateBandEnergies(peaks);\r\n        console.log('Band energies:', bandEnergies);\r\n        \r\n        // Find the band with the highest energy\r\n        let maxEnergy = 0;\r\n        let dominantNote = null;\r\n        \r\n        for (const [note, energy] of Object.entries(bandEnergies)) {\r\n            if (energy > maxEnergy) {\r\n                maxEnergy = energy;\r\n                dominantNote = note;\r\n            }\r\n        }\r\n\r\n        if (dominantNote) {\r\n            console.log('Dominant note:', dominantNote, 'Energy:', maxEnergy);\r\n            return {\r\n                freq: this.frequencyBands[dominantNote].center,\r\n                confidence: maxEnergy\r\n            };\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    findPeaks(magnitudeSpectrum, deltaFreq) {\r\n        const peaks = [];\r\n        const minIndex = Math.floor(this.minFreq / deltaFreq);\r\n        const maxIndex = Math.min(\r\n            Math.floor(this.maxFreq / deltaFreq),\r\n            magnitudeSpectrum.length\r\n        );\r\n\r\n        // Find local maxima with adjusted threshold for lower frequencies\r\n        for (let i = minIndex + 1; i < maxIndex - 1; i++) {\r\n            if (magnitudeSpectrum[i] > magnitudeSpectrum[i - 1] && \r\n                magnitudeSpectrum[i] > magnitudeSpectrum[i + 1]) {\r\n                const freq = i * deltaFreq;\r\n                const amplitude = magnitudeSpectrum[i];\r\n                \r\n                // Use a lower threshold for frequencies around A2\r\n                const threshold = (freq > 100 && freq < 120) ? 0.05 : 0.1;\r\n                \r\n                // Only consider significant peaks\r\n                if (amplitude > threshold * Math.max(...magnitudeSpectrum)) {\r\n                    peaks.push({\r\n                        freq,\r\n                        amplitude\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return peaks;\r\n    }\r\n\r\n    calculateBandEnergies(peaks) {\r\n        const bandEnergies = {};\r\n        \r\n        // Initialize energies for all bands\r\n        for (const note of Object.keys(this.frequencyBands)) {\r\n            bandEnergies[note] = 0;\r\n        }\r\n\r\n        // Calculate energy in each band\r\n        for (const peak of peaks) {\r\n            for (const [note, band] of Object.entries(this.frequencyBands)) {\r\n                if (peak.freq >= band.min && peak.freq <= band.max) {\r\n                    // Add energy to the band, weighted by how close to center\r\n                    const distanceFromCenter = Math.abs(peak.freq - band.center);\r\n                    const weight = 1 - (distanceFromCenter / (band.max - band.min));\r\n                    bandEnergies[note] += peak.amplitude * weight;\r\n                }\r\n            }\r\n        }\r\n\r\n        return bandEnergies;\r\n    }\r\n\r\n    calculateFFT(data) {\r\n        const n = data.length;\r\n        const fft = new Float32Array(n / 2);\r\n        const real = new Float32Array(data);\r\n        const imag = new Float32Array(n).fill(0);\r\n\r\n        // Perform FFT\r\n        this.fft(real, imag);\r\n\r\n        // Calculate magnitude spectrum\r\n        for (let i = 0; i < fft.length; i++) {\r\n            fft[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);\r\n        }\r\n\r\n        return fft;\r\n    }\r\n\r\n    fft(real, imag) {\r\n        const n = real.length;\r\n        if (n <= 1) return;\r\n\r\n        // Bit reversal\r\n        for (let i = 0; i < n; i++) {\r\n            const j = this.reverseBits(i, Math.log2(n));\r\n            if (j > i) {\r\n                [real[i], real[j]] = [real[j], real[i]];\r\n                [imag[i], imag[j]] = [imag[j], imag[i]];\r\n            }\r\n        }\r\n\r\n        // Cooley-Tukey FFT\r\n        for (let size = 2; size <= n; size *= 2) {\r\n            const halfsize = size / 2;\r\n            const tablestep = n / size;\r\n            for (let i = 0; i < n; i += size) {\r\n                for (let j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\r\n                    const tpre = real[j + halfsize] * Math.cos(2 * Math.PI * k / n) +\r\n                               imag[j + halfsize] * Math.sin(2 * Math.PI * k / n);\r\n                    const tpim = -real[j + halfsize] * Math.sin(2 * Math.PI * k / n) +\r\n                               imag[j + halfsize] * Math.cos(2 * Math.PI * k / n);\r\n                    real[j + halfsize] = real[j] - tpre;\r\n                    imag[j + halfsize] = imag[j] - tpim;\r\n                    real[j] += tpre;\r\n                    imag[j] += tpim;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    reverseBits(x, bits) {\r\n        let y = 0;\r\n        for (let i = 0; i < bits; i++) {\r\n            y = (y << 1) | (x & 1);\r\n            x >>>= 1;\r\n        }\r\n        return y;\r\n    }\r\n\r\n    findClosestNote(frequency) {\r\n        if (!frequency) return { note: null, frequency: null, difference: Infinity, cents: 0 };\r\n        \r\n        let closestNote = null;\r\n        let minDiff = Infinity;\r\n\r\n        // First check extended notes (including higher octaves)\r\n        for (const [note, freq] of Object.entries(this.extendedNotes)) {\r\n            const diff = Math.abs(freq - frequency);\r\n            if (diff < minDiff) {\r\n                minDiff = diff;\r\n                closestNote = note;\r\n            }\r\n        }\r\n\r\n        const targetFreq = this.extendedNotes[closestNote];\r\n        const cents = this.calculateCents(frequency, targetFreq);\r\n\r\n        return {\r\n            note: closestNote,\r\n            frequency: targetFreq,\r\n            difference: minDiff,\r\n            cents: cents\r\n        };\r\n    }\r\n\r\n    calculateCents(actualFreq, targetFreq) {\r\n        if (!actualFreq || !targetFreq) return 0;\r\n        return Math.round(1200 * Math.log2(actualFreq / targetFreq));\r\n    }\r\n\r\n    getTuningStatus(currentFreq, targetFreq) {\r\n        if (!targetFreq) return '';\r\n        \r\n        const diff = currentFreq - targetFreq;\r\n        if (Math.abs(diff) < 0.5) return 'Perfect!';\r\n        return diff > 0 ? 'Too high' : 'Too low';\r\n    }\r\n} \n\n//# sourceURL=webpack://guitar-tuner/./src/note-detector.js?");

/***/ }),

/***/ "./src/tuner.js":
/*!**********************!*\
  !*** ./src/tuner.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tuner: () => (/* binding */ Tuner)\n/* harmony export */ });\n/* harmony import */ var _note_detector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./note-detector.js */ \"./src/note-detector.js\");\n/* harmony import */ var _metronome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./metronome.js */ \"./src/metronome.js\");\n\r\n\r\n\r\nclass Tuner {\r\n    constructor() {\r\n        this.audioContext = null;\r\n        this.analyser = null;\r\n        this.mediaStream = null;\r\n        this.noteDetector = null;\r\n        this.isListening = false;\r\n        this.selectedNote = null;\r\n        this.currentView = 'basic';\r\n        \r\n        // Metronome instance\r\n        this.metronome = new _metronome_js__WEBPACK_IMPORTED_MODULE_1__.Metronome();\r\n        this.metronomeUpdateInterval = null;\r\n        \r\n        this.initializeUI();\r\n        this.setupEventListeners();\r\n    }\r\n\r\n    async initializeUI() {\r\n        // Set default view\r\n        this.currentView = 'basic';\r\n        this.updateView();\r\n\r\n        // Initialize microphone selection\r\n        try {\r\n            const devices = await navigator.mediaDevices.enumerateDevices();\r\n            const micSelect = document.getElementById('micSelect');\r\n            const audioInputs = devices.filter(device => device.kind === 'audioinput');\r\n            \r\n            audioInputs.forEach(input => {\r\n                const option = document.createElement('option');\r\n                option.value = input.deviceId;\r\n                option.text = input.label || `Microphone ${micSelect.length + 1}`;\r\n                micSelect.appendChild(option);\r\n            });\r\n\r\n            if (audioInputs.length > 0) {\r\n                micSelect.value = audioInputs[0].deviceId;\r\n            }\r\n        } catch (error) {\r\n            console.error('Error getting audio devices:', error);\r\n        }\r\n    }\r\n\r\n    setupEventListeners() {\r\n        // View selector buttons\r\n        document.getElementById('btnBasic').addEventListener('click', () => {\r\n            this.currentView = 'basic';\r\n            this.updateView();\r\n        });\r\n        document.getElementById('btnMetronome').addEventListener('click', () => {\r\n            this.currentView = 'metronome';\r\n            this.updateView();\r\n        });\r\n\r\n        // Microphone selection\r\n        document.getElementById('micSelect').addEventListener('change', (e) => {\r\n            if (this.isListening) {\r\n                this.stopListening();\r\n                this.startListening();\r\n            }\r\n        });\r\n\r\n        // Start/Stop button\r\n        document.getElementById('startButton').addEventListener('click', () => {\r\n            if (this.isListening) {\r\n                this.stopListening();\r\n            } else {\r\n                this.startListening();\r\n            }\r\n        });\r\n\r\n        // Note buttons (Basic View)\r\n        document.querySelectorAll('.note-button').forEach(button => {\r\n            button.addEventListener('click', () => {\r\n                this.selectNote(button.dataset.note);\r\n            });\r\n        });\r\n\r\n        // Metronome controls\r\n        this.setupMetronomeEventListeners();\r\n    }\r\n\r\n    setupMetronomeEventListeners() {\r\n        // Tempo controls\r\n        const tempoSlider = document.getElementById('tempoSlider');\r\n        const tempoInput = document.getElementById('tempoInput');\r\n        \r\n        tempoSlider.addEventListener('input', (e) => {\r\n            const tempo = parseInt(e.target.value);\r\n            tempoInput.value = tempo;\r\n            this.metronome.setTempo(tempo);\r\n            this.updateMetronomeDisplay();\r\n        });\r\n        \r\n        tempoInput.addEventListener('input', (e) => {\r\n            const tempo = parseInt(e.target.value);\r\n            tempoSlider.value = tempo;\r\n            this.metronome.setTempo(tempo);\r\n            this.updateMetronomeDisplay();\r\n        });\r\n\r\n        // Volume control\r\n        const volumeSlider = document.getElementById('volumeSlider');\r\n        const volumeDisplay = document.getElementById('volumeDisplay');\r\n        \r\n        volumeSlider.addEventListener('input', (e) => {\r\n            const volume = parseInt(e.target.value) / 100;\r\n            volumeDisplay.textContent = `${e.target.value}%`;\r\n            this.metronome.setVolume(volume);\r\n        });\r\n\r\n        // Time signature controls\r\n        const beatsSelect = document.getElementById('beatsSelect');\r\n        const divisionSelect = document.getElementById('divisionSelect');\r\n        \r\n        beatsSelect.addEventListener('change', () => {\r\n            this.updateTimeSignature();\r\n        });\r\n        \r\n        divisionSelect.addEventListener('change', () => {\r\n            this.updateTimeSignature();\r\n        });\r\n\r\n        // Metronome buttons\r\n        const metronomeStartButton = document.getElementById('metronomeStartButton');\r\n        \r\n        metronomeStartButton.addEventListener('click', () => {\r\n            this.toggleMetronome();\r\n        });\r\n    }\r\n\r\n    updateTimeSignature() {\r\n        const beats = parseInt(document.getElementById('beatsSelect').value);\r\n        const division = parseInt(document.getElementById('divisionSelect').value);\r\n        this.metronome.setTimeSignature(beats, division);\r\n        this.updateBeatIndicator();\r\n    }\r\n\r\n    updateBeatIndicator() {\r\n        const beatIndicator = document.getElementById('beatIndicator');\r\n        const beats = parseInt(document.getElementById('beatsSelect').value);\r\n        \r\n        // Clear existing dots\r\n        beatIndicator.innerHTML = '';\r\n        \r\n        // Create dots for each beat\r\n        for (let i = 0; i < beats; i++) {\r\n            const dot = document.createElement('div');\r\n            dot.className = 'beat-dot';\r\n            if (i === 0) {\r\n                dot.classList.add('accent');\r\n            }\r\n            beatIndicator.appendChild(dot);\r\n        }\r\n    }\r\n\r\n    toggleMetronome() {\r\n        if (this.metronome.isPlaying) {\r\n            this.stopMetronome();\r\n        } else {\r\n            this.startMetronome();\r\n        }\r\n    }\r\n\r\n    startMetronome() {\r\n        this.metronome.start();\r\n        this.updateMetronomeUI();\r\n        this.startMetronomeUpdates();\r\n    }\r\n\r\n    stopMetronome() {\r\n        this.metronome.stop();\r\n        this.updateMetronomeUI();\r\n        this.stopMetronomeUpdates();\r\n    }\r\n\r\n    updateMetronomeUI() {\r\n        const startButton = document.getElementById('metronomeStartButton');\r\n        const display = document.getElementById('metronomeDisplay');\r\n        \r\n        if (this.metronome.isPlaying) {\r\n            startButton.textContent = 'Stop Metronome';\r\n            startButton.classList.add('playing');\r\n        } else {\r\n            startButton.textContent = 'Start Metronome';\r\n            startButton.classList.remove('playing');\r\n            display.classList.remove('playing', 'accent');\r\n        }\r\n    }\r\n\r\n    startMetronomeUpdates() {\r\n        this.metronomeUpdateInterval = setInterval(() => {\r\n            this.updateMetronomeDisplay();\r\n        }, 50); // Update every 50ms for smooth animation\r\n    }\r\n\r\n    stopMetronomeUpdates() {\r\n        if (this.metronomeUpdateInterval) {\r\n            clearInterval(this.metronomeUpdateInterval);\r\n            this.metronomeUpdateInterval = null;\r\n        }\r\n    }\r\n\r\n    updateMetronomeDisplay() {\r\n        const display = document.getElementById('metronomeDisplay');\r\n        const beatDots = document.querySelectorAll('.beat-dot');\r\n        \r\n        // Update tempo display\r\n        display.textContent = `${this.metronome.tempo} BPM`;\r\n        \r\n        // Update beat indicator\r\n        if (this.metronome.isPlaying) {\r\n            const currentBeat = this.metronome.getCurrentBeat() - 1;\r\n            const isAccent = this.metronome.isAccentBeat();\r\n            \r\n            // Reset all dots\r\n            beatDots.forEach((dot, index) => {\r\n                dot.classList.remove('active');\r\n                if (index === 0) {\r\n                    dot.classList.add('accent');\r\n                } else {\r\n                    dot.classList.remove('accent');\r\n                }\r\n            });\r\n            \r\n            // Highlight current beat\r\n            if (beatDots[currentBeat]) {\r\n                beatDots[currentBeat].classList.add('active');\r\n                if (isAccent) {\r\n                    display.classList.add('accent');\r\n                } else {\r\n                    display.classList.remove('accent');\r\n                }\r\n                display.classList.add('playing');\r\n                \r\n                // Remove playing class after animation\r\n                setTimeout(() => {\r\n                    display.classList.remove('playing');\r\n                }, 500);\r\n            }\r\n        }\r\n    }\r\n\r\n    updateView() {\r\n        const tunerViews = document.getElementById('tunerViews');\r\n        const metronomeView = document.getElementById('metronomeView');\r\n        // Update button active state\r\n        document.querySelectorAll('.view-btn').forEach(btn => {\r\n            btn.classList.remove('active');\r\n        });\r\n        if (this.currentView === 'basic') {\r\n            document.getElementById('btnBasic').classList.add('active');\r\n        } else if (this.currentView === 'metronome') {\r\n            document.getElementById('btnMetronome').classList.add('active');\r\n        }\r\n\r\n        if (this.currentView === 'metronome') {\r\n            tunerViews.style.display = 'none';\r\n            metronomeView.style.display = 'block';\r\n            metronomeView.classList.add('active');\r\n            this.updateBeatIndicator();\r\n            this.updateMetronomeDisplay();\r\n        } else {\r\n            tunerViews.style.display = 'block';\r\n            metronomeView.style.display = 'none';\r\n            metronomeView.classList.remove('active');\r\n            // Update specific tuner view\r\n            const basicView = document.getElementById('basicView');\r\n            basicView.style.display = 'grid';\r\n        }\r\n    }\r\n\r\n    selectNote(note) {\r\n        this.selectedNote = note;\r\n        \r\n        // Update active state in basic view\r\n        document.querySelectorAll('.note-button').forEach(button => {\r\n            button.classList.toggle('active', button.dataset.note === note);\r\n        });\r\n    }\r\n\r\n    async startListening() {\r\n        try {\r\n            const micSelect = document.getElementById('micSelect');\r\n            const constraints = {\r\n                audio: {\r\n                    deviceId: micSelect.value ? { exact: micSelect.value } : undefined\r\n                }\r\n            };\r\n\r\n            this.mediaStream = await navigator.mediaDevices.getUserMedia(constraints);\r\n            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();\r\n            this.analyser = this.audioContext.createAnalyser();\r\n            this.analyser.fftSize = 32768;\r\n            \r\n            const source = this.audioContext.createMediaStreamSource(this.mediaStream);\r\n            source.connect(this.analyser);\r\n            \r\n            this.noteDetector = new _note_detector_js__WEBPACK_IMPORTED_MODULE_0__.NoteDetector(this.audioContext.sampleRate);\r\n            this.isListening = true;\r\n            \r\n            document.getElementById('startButton').textContent = 'Stop Tuning';\r\n            document.getElementById('startButton').classList.add('listening');\r\n            \r\n            this.processAudio();\r\n        } catch (error) {\r\n            console.error('Error starting audio:', error);\r\n            alert('Error accessing microphone. Please make sure you have granted permission.');\r\n        }\r\n    }\r\n\r\n    stopListening() {\r\n        if (this.mediaStream) {\r\n            this.mediaStream.getTracks().forEach(track => track.stop());\r\n        }\r\n        if (this.audioContext) {\r\n            this.audioContext.close();\r\n        }\r\n        this.isListening = false;\r\n        this.mediaStream = null;\r\n        this.audioContext = null;\r\n        this.analyser = null;\r\n        \r\n        document.getElementById('startButton').textContent = 'Start Tuning';\r\n        document.getElementById('startButton').classList.remove('listening');\r\n        document.getElementById('tuningStatus').textContent = '';\r\n        document.getElementById('frequencyDisplay').textContent = '';\r\n    }\r\n\r\n    processAudio() {\r\n        if (!this.isListening) return;\r\n\r\n        const bufferLength = this.analyser.frequencyBinCount;\r\n        const dataArray = new Float32Array(bufferLength);\r\n        this.analyser.getFloatTimeDomainData(dataArray);\r\n\r\n        const { frequency, amplitude } = this.noteDetector.findPeakFrequency(dataArray);\r\n        const frequencyDisplay = document.getElementById('frequencyDisplay');\r\n        const tuningStatus = document.getElementById('tuningStatus');\r\n        \r\n        // Always show frequency if detected\r\n        if (frequency) {\r\n            frequencyDisplay.textContent = `${frequency.toFixed(1)} Hz`;\r\n            \r\n            if (amplitude > 0.1) {  // Only show note if we have a strong enough signal\r\n                const { note, cents } = this.noteDetector.findClosestNote(frequency);\r\n                \r\n                if (this.selectedNote) {\r\n                    if (note === this.selectedNote) {\r\n                        if (Math.abs(cents) < 5) {\r\n                            tuningStatus.textContent = 'In Tune!';\r\n                            tuningStatus.style.color = '#4CAF50';\r\n                        } else {\r\n                            const direction = cents > 0 ? 'too high' : 'too low';\r\n                            tuningStatus.textContent = `${Math.abs(cents).toFixed(1)} cents ${direction}`;\r\n                            tuningStatus.style.color = '#f44336';\r\n                        }\r\n                    } else {\r\n                        tuningStatus.textContent = `Playing ${note} (target: ${this.selectedNote})`;\r\n                        tuningStatus.style.color = '#f44336';\r\n                    }\r\n                } else {\r\n                    tuningStatus.textContent = `Playing ${note}`;\r\n                    tuningStatus.style.color = '#2196F3';\r\n                }\r\n            } else {\r\n                tuningStatus.textContent = 'Weak signal';\r\n                tuningStatus.style.color = '#666';\r\n            }\r\n        } else {\r\n            frequencyDisplay.textContent = 'No frequency detected';\r\n            tuningStatus.textContent = 'No note detected';\r\n            tuningStatus.style.color = '#666';\r\n        }\r\n\r\n        requestAnimationFrame(() => this.processAudio());\r\n    }\r\n\r\n    destroy() {\r\n        this.stopListening();\r\n        this.stopMetronome();\r\n        if (this.metronome) {\r\n            this.metronome.destroy();\r\n        }\r\n    }\r\n}\r\n\r\n// Initialize the tuner when the page loads\r\nwindow.addEventListener('load', () => {\r\n    new Tuner();\r\n}); \n\n//# sourceURL=webpack://guitar-tuner/./src/tuner.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/tuner.js");
/******/ 	
/******/ })()
;